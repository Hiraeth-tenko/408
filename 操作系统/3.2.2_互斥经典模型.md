---
aliases:
tags:
  - 操作系统
date created: 2023-10-08 日 08:08:22
date modified: 2023-10-08 日 08:08:57
---

# Link

---

Previous: [3.2.1\_同步与互斥](3.2.1_同步与互斥.md)

Next: [3.3\_死锁](3.3_死锁.md)

# 互斥经典模型

---

## 消费者-生产者

消费者与生产者问题通常涉及两种类型的进程或线程：生产者负责生成数据并将其放入共享缓冲区，而消费者负责从缓冲区中取出数据并进行处理。

- **消费者和生产者互斥进入共享缓冲区**
- 共享缓冲区：创建一个共享缓冲区，用于生产者将数据放入，消费者从中取出。
- 互斥锁：创建一个互斥锁，用于保护共享缓冲区的访问。这个锁用于确保在任何时刻只有一个线程可以访问缓冲区。
- 条件变量：创建两个条件变量，一个用于通知生产者可以生产数据，另一个用于通知消费者可以消费数据。这些条件变量用于在线程等待数据可用或缓冲区可用时进行阻塞和唤醒操作。

```c
// 定义信号量和计数器
Semaphore mutex = 1;         // 用于互斥访问共享缓冲区
Semaphore empty = N;         // 用于表示缓冲区空闲槽位数量
Semaphore full = 0;          // 用于表示缓冲区已存放数据项数量

function producer() {
    while (true) {
        item = produce_item();  // 生成一个新的数据项

        P(empty);               // 等待至少有一个空槽位
        P(mutex);               // 进入互斥区

        // 将数据项放入缓冲区
        insert_item(item);

        V(mutex);               // 退出互斥区
        V(full);                // 通知消费者有数据可用
    }
}

function consumer() {
    while (true) {
        P(full);                // 等待至少有一个数据项
        P(mutex);               // 进入互斥区

        // 从缓冲区取出一个数据项
        item = remove_item();

        V(mutex);               // 退出互斥区
        V(empty);               // 通知生产者有空槽位

        consume_item(item);     // 消费数据项
    }
}

```

## 读者-写者

多个读者可以同时访问共享资源，但它们之间不应该互斥。这是因为读取操作不会修改共享资源，多个读者可以同时读取而不会互相干扰。

只有一个写者可以访问共享资源，并且在写者访问期间，不允许其他读者或写者进入。这是因为写操作会修改共享资源，需要确保写操作的互斥性。

- **读者之间不互斥进入共享资源，写者与其他互斥进入共享资源**
- 共享资源：创建一个共享资源，多个读者可以同时访问共享资源，但不与写者并发；只有一个写者可以访问共享资源，写者访问时其他写者、读者不与之并发。
- 互斥锁：创建一个互斥锁，用于保护共享资源的访问。这个锁用于保证读者与写者不同时访问共享资源。
- 条件变量：创建两个条件变量，一个记录访问共享资源的读者数量，另一个用于控制写者的访问。

```c
// 定义信号量和计数器
Semaphore mutex = 1;        // 用于互斥访问读者计数器
Semaphore wrt = 1;          // 用于互斥访问写者

int readers = 0;            // 读者计数器，记录当前读者数量

// 读者代码
function reader() {
    P(mutex);               // 进入互斥区，阻止其他读者进入
    readers++;
    if (readers == 1) {
        P(wrt);             // 如果是第一个读者，阻止写者进入
    }
    V(mutex);               // 退出互斥区

    read_shared_resource(); // 读取共享资源

    P(mutex);               // 进入互斥区
    readers--;
    if (readers == 0) {
        V(wrt);             // 如果是最后一个读者，允许写者进入
    }
    V(mutex);               // 退出互斥区
}

// 写者代码
function writer() {
    P(wrt);                 // 阻止其他写者和读者进入

    write_shared_resource();// 写入共享资源

    V(wrt);                 // 允许其他写者和读者进入
}

```

## 哲学家进餐

每位哲学家交替地考虑思考和进餐。哲学家只有在同时拿到左手和右手的筷子时才能进餐。哲学家在进餐完毕后应该释放筷子，以供其他哲学家使用。

- **制定规则使得哲学家不会陷入死锁**
- 共享资源：创建多根筷子，每个哲学家一根
- 互斥锁：创建一个互斥锁，用于哲学家互斥地获取筷子

```c
// 定义信号量和计数器
Semaphore chopstick = [1,1,1,1,1]; // 初始化信号量
Semaphore mutex = 1;               // 用于互斥获取筷子

function Pi() {
    do {
        P(mutex);                  // 互斥获取筷子
        P(chopstick[i]);           // 取左筷子
        P(chopstick[(i+1)%5]);     // 取右筷子
        V(mutex);                  // 释放取筷子信号量
        eat();                     // 进餐
        V(chopstick[i]);           // 释放左筷子
        V(chopstick[(i+1)%5]);     // 释放右筷子
        think();                   // 思考
    } while(true)
}
```

## 吸烟者问题

三个吸烟者和一个中介（经销商）之间的互动。每位吸烟者都有一个特定类型的材料（例如烟草、纸和胶水），但他们缺少其他两种材料以制作卷烟。中介有无限的供应三种材料，但只能供应其中两种。

- 共享资源：创建三个共享资源，分别段表烟草、纸、胶水。
- 互斥锁：创建一个互斥锁，用于

```
// 定义信号量和互斥锁
Semaphore tobacco = 0;     // 烟草信号量
Semaphore paper = 0;       // 纸信号量
Semaphore glue = 0;        // 胶水信号量
Semaphore agent = 1;       // 代理信号量，用于中介的互斥

// 吸烟者线程
function smoker_i(item) {
    while (true) {
        P(item);  // 等待所需材料的信号

        make_and_smoke(); // 制作并吸烟

        V(agent); // 通知中介有空闲资源
    }
}

// 中介线程
function agent() {
    while (true) {
        P(agent);  // 等待中介的互斥锁

        int random_choice = random(0, 2); // 随机选择两种材料

        // 根据选择供应相应的材料
        if (random_choice == 0) {
            V(tobacco);  // 供应烟草和纸
            V(paper);
        } else if (random_choice == 1) {
            V(paper);    // 供应纸和胶水
            V(glue);
        } else {
            V(glue);     // 供应烟草和胶水
            V(tobacco);
        }
    }
}

```

# Relative

---

[3.2.1\_同步与互斥](3.2.1_同步与互斥.md)

# Reference

---
