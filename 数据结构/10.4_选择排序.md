---
aliases: 
tags:
  - 数据结构
date created: 2023-10-25 三 08:08:46
date modified: 2023-10-30 一 04:30:08
---

# Link

---
Previous: [10.3_交换排序](10.3_交换排序.md)

Next: [10.5_归并排序](10.5_归并排序.md)

# 选择排序

---

选择排序与插入排序思想类似：将序列分为已排序的有序序列和未排序的无序序列，每次从无序序列中选取最小的元素插入有序序列中。

## 简单选择排序

### 方法

第 $i$ 躺排序时，有待排序表 $L$ 如下

| 有序序列 $L[1\cdot\cdot\cdot i-1]$ | 无序序列 $L[i\cdot\cdot\cdot n]$ |
| ---------------------------------- | -------------------------------- |

- 从无序序列 $L[i\cdot\cdot\cdot n]$ 中选出最小/大元素 $L[k]$ 与元素 $L[i]$ 交换位置。
- 重复上一步直到整个序列有序

### 性能分析

- 空间复杂度：$O(1)$
- 时间复杂度：$O(n^2)$
  - 最好情况：$O(n^2)$
  - 最坏情况：$O(n^2)$
- 稳定性：不稳定
- 适用性：顺序存储、链式存储

## 堆排序

### 方法

堆排序基于二叉树，分为大根（顶）堆和小根（顶）堆。

- 大根堆：$L (i)\ge L(2i)$ 且 $L (i)\ge L(2i+1)$
- 小根堆：$L (i)\le L(2i)$ 且 $L (i)\le L(2i+1)$

堆排序的主要思想是：将待排序的元素构建成一个二叉堆，然后重复地将堆顶元素与堆中的最后一个元素交换，然后减小堆的大小，再进行堆的维护，直到所有元素有序：

- 堆化：将待排序的数组视为一个完全二叉树，然后从最后一个非叶子节点开始，开始向前遍历，对每个节点执行一次下沉操作，使得该节点及其子树满足堆的性质，即满足 $L (i)\ge L(2i)$ 且 $L (i)\ge L(2i+1)$ 。
- 输出堆顶元素，将堆顶元素与最后一个元素交换（之前的交换下来的元素不视为堆内元素）。此时堆性质遭到破坏，再次对堆进行维护，将根节点下沉到满足堆性质的位置。

### 性能分析

- 空间复杂度：$O(1)$， 堆排序是一种原地排序算法，不需要额外的内存空间
- 时间复杂度：$O(nlog_n)$
  - 最好情况：$O(nlog_n)$
  - 最差情况：$O(nlog_n)$ 其中 n 是待排序元素的数量。这使得堆排序在大多数情况下都能够提供较好的性能。
- 稳定性：不稳定
- 适用性：顺序存储
  - 堆排序使用链式存储时，时间复杂度变为 $O(n^2log_n)$，因为每趟都需要寻找最后一个元素并与顶部元素交换。
  - 堆排序还适用于外部排序，因为它不需要将整个数据集加载到内存中。

# Relative

---
[10.1_内部排序](10.1_内部排序.md)

# Reference

---
