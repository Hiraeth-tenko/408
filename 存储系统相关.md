---
aliases: []
tags:
  - 计算机组成原理
  - 操作系统
date created: 2023-08-15 二 06:30:52
date modified: 2023-09-27 三 08:04:12
---

# 存储系统相关

---

整理一下计组和操作系统中存储系统交叉的知识。

## 局部性原理

- 时间局部性原理：程序中存在大量的循环语句，使得最近未来要使用的数据是现在正在使用的数据。
- 空间局部性原理：数据在存储空间上是相邻的，因此最近未来要使用的数据和现在正在使用的数据在在空间上关联。

## Cache

Cache 的块数远少于主存，Cache 记录主存中数据的副本，以便 CPU 通过访问 Cache 更快速的获得数据。
Cache 每一块称作一行，一行 Cache 由标记和记录的数据构成。其中标记根据 Cache 和主存之间建立的映射关系不同构成也不同。

### 映射方式

#### 直接映射

主存地址结构：标记 ($t$) + Cache 行号 ($c$) + 块内地址。其中，标记 ($t$) + Cache 行号 ($c$) = 主存块号 $m$。
Cache 行结构：标记 ($t$) + 数据

假设 Cache 有 $2^c$ 行，主存有 $2^m$ 块。
$Cache 行号 = 主存块号 ~\%~ Cache 行数$
$标记位数 t = m - c$，取主存地址高 $t$ 位作为标记。标记用于确认 Cache 内记录的数据是否与访存地址对应。
根据编址方式（按字编址，按字节编址），主存块的大小等因素，一块主存块不一定只对应一个地址，在主存块内还有块内地址。
比方说：Cache 有 $2^{10}$ 行，主存有 $2^{20}$ 块，主存块大小 $2^4B$ ，按字节编址，主存地址 24 位。
那么主存地址结构为：标记 ($10$)+Cache 行号 ($10$)+块内地址 ($4$)

#### 全相联映射

主存地址结构：标记 ($t$) + 块内地址。其中，标记 ($t$) = 主存块号 $m$。
Cache 行结构：标记 ($t$) + 数据
任意一块主存块可以映射到任意一行 Cache，CPU 依次检查每一行 Cache 的标记。

#### 组相联映射

主存地址结构：标记 ($t$) + 组号 ($c$) + 块内地址。其中，标记 ($t$) + 组号 ($c$) = 主存块号 $m$。
Cache 行结构：标记 ($t$) + 数据

假设 Cache 有 $2^c$ 组，每组有 $r$ 行，主存有 $2^m$ 块。
$Cache 组号 = 主存块号 ~\%~ Cache组数$
$标记位数 t = m - c$
根据 $r$ 的值，称为 $r$ 路联组。
CPU 根据访存地址计算出组号，再到对应的 Cache 组内比较标记。
$r=1$ 时，组相联等于直接映射；$r=2^c$ 时，组相联映射等于全相联映射。

### 写策略

#### 写命中

- 全写法 (写直通法、write-through)：Cache 命中时，同时把数据写入 Cache 和主存。写缓冲，由于直接写入主存速度较慢，建立一个写缓冲队列，先写入 Cache 和写缓冲队列，再由写缓冲队列写入主存。
- 写回法 (write-back)：Cache 命中时，仅把数据写入 Cache，待 Cache 行要被替换时，此时写入主存。需要一位修改位 (脏位)，修改位为 1 时，表示被修改，替换时需要写回主存；为 0 时，表示未被修改，不需要写回主存。

#### 写未命中

- 非写分配法：通常与全写法搭配使用，直接把修改的数据写入主存。
- 写分配法：通常与写回法搭配使用，先把主存块调入 Cache，修改对应的 Cache 块。

## 替换算法

Cache 在使用组相联、全相联映射时需要替换 Cache 行、虚拟内存管理页面时需要替换页面等，这些场景均需要使用替换算法。

### Cache 使用的算法

#### 随机替换

顾名思义，随机选择要替换的 Cache 行，实现简单，局部性差。

#### 先进先出 (FIFO)

选择最先调入的 Cache 行替换出去，实现简单，局部性差。

#### 近期最少使用 (LRU)

根据局部性原理，每次选择最近最少使用的 Cache 行替换。
该算法为每一个 Cache 行设置一个计数器，计数器按如下规则变化：

1. 命中时，比命中行计数器低的其余行计数器加一，命中行计数器清零，其余行不变。
2. 未命中且有空闲行时，其余行计数器加一，置入的新行计数器置零。
3. 未命中且无空闲行时，计数器最高的行被替换为新行，置入的新行计数器置零，其余行计数器加一。

### 页面调度算法

#### 最佳置换 (OPT)

选择不再访问，或将未来最长时间不访问的页面替换出，得到最小的缺页率。

#### 先进先出 (FIFO)

Belady：分配物理块数增加而页故障次数不减反增。
同 Cache 部分。

#### 最近最少使用(LRU)

同 Cache 部分。

#### 时钟 (CLOCK)

又称最近未用 (NRU)。
为每页设置一个访问位 $A$，将内存中所有页面看作一个循环队列。选择要替换的页面时，检查访问位：1)、访问位为 1，置 0；2)、访问位为 0，替换出；由于是循环队列，遍历一遍没有访问位为 0 的页面，遍重新遍历。页面置入时访问位置 1。

#### 改进时钟

增加了一个修改位 $M$。
访问位 $A$ 和修改位 $M$ 构成 4 种情况：

- $00$：未访问未修改，最佳淘汰页；
- $01$：未访问已修改，次级淘汰页；
- $10$：已访问未修改，次次级淘汰页；
- $11$：已访问已修改，最次淘汰页；
  进行多轮遍历：
- 第一轮，寻找 $AM=00$ 的页面，将第一个遭遇的页面淘汰；
- 第二轮，寻找 $AM=01$ 的页面，将第一个遭遇的页面淘汰，同时将访问位置 0；
- 第三轮，寻找 $AM=01$ 的页面，将第一个遭遇的页面淘汰；
- 每一轮淘汰了页面就不再继续后续扫描。

## 基本分页存储管理

分页存储管理提高内存利用率。
进程的块称为**页或页面 (Page)**，内存的块称为**页框或页帧 (Page Frame)**，外存的块称为**块或盘块 (Block)**，块的大小通常一致。

逻辑地址结构：页号 ($p$) + 页内偏移量 ($w$)。
页表项结构：页号 ($p$) + 物理内存块号 ($b$)。

### 页表

操作系统为每个进程分配一个页表，页表由页表项组成。页表存在于内存中，通过页表将逻辑地址映射到物理内存。一个页表内含有 $2^w$ 个页表项，最多有 $2^p$ 个页面。

页表项大小：对于 $32$ 位逻辑地址，按字节编址，页大小 $4KB$ 为例，计算得知虚拟地址空间内共有 $2^{32}B / 4KB = 1M$ 页 (页框)，故使用 $20$ 位对 $1M$ 页进行编号。页表是一个一维数组，以页号为下标，块号是其存储的内容，则一个页表项的大小就等于一个块号的大小。由于进程、内存的块一样大，故页号大小等于块号大小。对于按字节编址的情况，一个页号大小 $=log_2\lceil{20/8}\rceil=3*1B=3B$，即一个页表项大小 $=3B$；对于按字 (一字对于二字节)编址的情况，一个页号大小 $=log_2\lceil{20/16}\rceil=2*2B=4B$，即一个页表项大小 $=4B$。

有页表起始地址 $F$，页表长度 $M$，页表项长度 $m$，系统中有一个页表寄存器，记录页表在内存的起始地址 $F$ 和页表长度 $M$；页面大小 $L$。
计算逻辑地址 $A$ 变换到物理地址 $E$：

1. 先计算 $页号 P=A/L$，$页内偏移量W=A\%L$。
2. 比较页号 $P$ 和页表长度 $M$，若 $P \ge M$ 则发生越界中断。
3. 得到页表项地址 $=F+P\times m$，取出物理块号 $b$。
4. 计算物理地址 $E=b\times L + W$

### 快表

引入一个快表 (TLB)，存放在 Cache 中，加快访问速度；与之相对，在主存中的页表称为慢表。

### 多级页表

**最高一级的页表只能有一页。**
二级页表的逻辑地址结构：一级页号 + 二级页号 + 页内偏移
一级页号检索出对应的二级页表，二级页表再使用二级页号检索对应的页内偏移。

## 基本分段存储管理

分段存储管理反映程序逻辑结构。
逻辑地址结构：段号 ($s$) + 段内偏移量 ($w$)
段表项结构：段号 ($s$) + 段长 ($c$) + 本段在主存的始指 ($a$)
由于段长不固定，无法计算段号和段内偏移量，因此需要用户显示给出。

### 段表

段表存在于内存中。一个段表内含有 $2^s$ 个段，段长最大为 $2^w$ 。一个进程只能有一个段表，但是可以有多个页表 (如多级页表)。

有段表起始地址 $F$，段表长度 $M$，段表项长度 $m$，系统中有一个段表寄存器，记录段表在内存的起始地址 $F$ 和段表长度 $M$；页面大小 $L$。
计算逻辑地址 $A$ 变换到物理地址 $E$：

1. 先取出段号 $s$ 和段内偏移量 $w$。
2. 比较段号 $s$ 和页表长度 $M$，若 $s \ge M$ 则发生越界中断。
3. 得到段表项地址 $=F+s\times m$，取出中间的段长 $c$，若 $w \ge c$ 则发生越界中断。
4. 取出始址 $b$，计算物理地址 $E=b + w$。

### 段的共享与保护

- 共享：多个段表项指向同一个被共享的段的物理副本。这些段表项段号不一定相同。
- 保护：越界保护和存取控制保护。

## 段页式管理

逻辑地址结构：段号 ($s$) + 页号 ($p$) + 业内偏移量 ($w$)
段页式管理中，作业根据逻辑段划分地址空间，然后每个段再划分为页。

## 虚拟内存管理

### 请求分页存储管理

请求页表的页表项结构：

- 页号 + 物理块号 + 状态位 $p$ + 访问字段 $a$ + 修改位 $m$ + 外存地址
- 状态位 $p$：是否调入内存
- 访问字段 $a$：记录一段时间内访问次数
- 修改位 $m$：记录是否被修改

驻留集：给一个进程分配的物理页框的集合。

#### 内存分配策略

**不存在固定分配全局置换**

##### 固定分配局部置换

每个进程固定个数物理块。缺页时，选出被替换的页，调入新页。物理块数一定。

##### 可变分配全局置换

先分配一定数量的物理块，根据运行情况增减。缺页时，系统从空闲物理块队列中分配给进程一块物理块。

##### 可变分配局部置换

先分配一定数量的物理块。缺页时，进行局部替换；若频繁缺页，则再给进程分配一定物理块使缺页率保持在较低的程度。

# Relative

---

# Reference

---
